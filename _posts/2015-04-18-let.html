---
layout: post
title:  "Let"
date:   2015-04-18 11:02:00
categories: bindings
---
<div class="sample-area">
  <div class="copy">
    <h1>Let</h1>
    {% markdown %}
let allows you to declare variables that are limited in scope to the block, statement, or expression on which it is used. This is unlike the var keyword, which defines a variable globally, or locally to an entire function regardless of block scope. The let works as expected, setting the variable in the place where it was declared.

There's no hoisting behavior for variables declared with let. If you reference a variable in a block before the let declaration for that variable is encountered, it will result in a ReferenceError. With the let keyword, we now have true block-level scoping!

In this example we have created a new function `foo` and then called it. As expected the last console statement will produce a `Reference Error` because x is only defined (scoped) inside the foo() function. The first console statement will execute just fine due to variable hoisting. In this case, `x` will evaluate to `undefined`. 

The second console statement, however, is more interesting. In fact, `both of the log(y) calls will fail` because the let keyword allows much tighter scoping than var. The y variable only exists inside of that if block, and no where else! 
{% endmarkdown %}

  </div>
  <div class="code">
  	{% highlight javascript linenos %}
function foo() {
  console.log( x );
  console.log( y );
  var x = 1;
  if (x === 1) {
    let y = 2;
  }
  console.log( y );
}
foo();
console.log( x );
{% endhighlight %}
  </div>
</div>

<div class="sample-area">
  <div class="copy">
    {% markdown %}
This example can be rewritten as -

The function now declares the `y` variable at the top of the function, thus giving it a larger scope than our first example. We can see that y is accessible anywhere inside this function, but not outside of it, that last `console.log(y)` statement will produce a `ReferenceError`.

The idea is that `var` will be discontinued in a distant future, because today it would be impossible completely stop supporting it without breaking the whole internet.
{% endmarkdown %}

  </div>
  <div class="code">
  	{% highlight javascript linenos %}
function foo( x ) {
  let y;
  if (x === 1) {
    y = 2;
  }
  console.log( y );
}
foo( 1 );
console.log( y );
{% endhighlight %}
  </div>
</div>